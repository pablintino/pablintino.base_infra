---
- name: Assert basic things about the connection
  ansible.builtin.assert:
    that:
      - >-
        'mode' in item.value and
        (
          item.value.mode == 'auto' or
          item.value.mode == 'manual'
        )
      - >-
        item.value.mode != 'manual' or
        (
          ('ip4' in item.value and (item.value.ip4 | ansible.utils.ipaddr != false)) and
          (('ip4gw' not in item.value) or (item.value.ip4gw | ansible.utils.ipaddr != false))
        )
      # Only ethernet is supported now
      - ('device-type' in item.value) and item.value['device-type'] == 'ethernet'
    quiet: true

- name: Assert that the device of the connection can be referenced
  ansible.builtin.assert:
    that: "'iface' in item.value and item.value.iface != ''"
    msg: "Connection {{ item.key }} references an interface that cannot be found"
    quiet: true

# Rename if interface is gonna be stolen from other interface (needs explicit flag)
- name: Rename exising connetion to match the name of the new one
  become: true
  vars:
    connection_active: "{{ item.value.nm_connection_info | pablintino.base_infra.nmcli_filter_is_active }}"
    target_uuid: "{{ item.value.nm_connection_info.connection_uuid }}"
  when: >-
    'nm_connection_info' in item.value and
    item.value.nm_connection_info.connection_id != item.key
  ansible.builtin.shell:
    # Rename and up in the same command, as sometimes the renames shutsdown the iface
    cmd: |-
      nmcli connection modify  '{{ target_uuid }}' connection.id '{{ item.key }}'
      {% if connection_active %}
        nmcli connection up {{ item.value.nm_connection_info.connection_uuid }}
      {% endif %}
  changed_when: true

- name: Setup network connection
  become: true
  community.general.nmcli:
    conn_name: "{{ item.key | lower }}"
    type: "{{ item.value['device-type'] }}"
    ip4: "{{ item.value.ip4 if item.value.mode == 'manual' else omit }}"
    gw4: >-
      {{
        (item.value.ip4gw | default(omit))
        if item.value.mode == 'manual' else
        omit
      }}
    dns4: "{{ item.value.dns | default(omit) }}"
    dns4_ignore_auto: "{{ item.value.dns | default([]) | length > 0 }}"
    never_default4: >-
      {{
        item.value.mode == 'manual' or
        (item.value.mode == 'auto' and (item.value.ignore_gw | default(false)))
        if ('ip4gw' not in item.value) else omit
      }}
    routes4_extended: >-
      {{
        item.value.routes |
        default([]) |
        pablintino.base_infra.nmcli_filter_rule2rich_rules
      }}
    ifname: "{{ item.value.iface }}"
    autoconnect: "{{ item.value.onboot | default(true) | bool }}"
    gw4_ignore_auto: "{{ item.value.ignore_gw | default(false) | bool }}"
    method4: "{{ item.value.mode }}"
    method6: disabled
    state: present

# Ensure the connection contains the proper state (ipv6 disabling get updated on up only)
- name: Ensure connection is UP
  become: true
  ansible.builtin.command:
    cmd: nmcli connection up "{{ item.key | lower }}"
  changed_when: false

- name: Fetch the connection status
  pablintino.base_infra.nmcli_get_connections:
    connection: "{{ item.key }}"
  retries: "{{ pbi_nstp_wait_for_ip_retries }}"
  delay: "{{ pbi_nstp_wait_for_ip_delay }}"
  register: _pbi_nstp_nm_last_connection_status
  until: >-
    'ip4_address' in _pbi_nstp_nm_last_connection_status.result and
    (_pbi_nstp_nm_last_connection_status.result.ip4_address | length > 0)
